/*
游戏规则是这样的：
n 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，
每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，
此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。
聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，
传了 m 次以后，又回到小蛮手里。
两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。
比如有三个同学 1 号、2 号、3 号，并假设小蛮为 1 号，球传了 3 次回到小蛮手里的方式有
1→2→3→1 和 1→3→2→1，共 2 种。
输入格式:
一行，有两个用空格隔开的整数 n,m(3≤n≤30,1≤m≤30)。
输出格式:
1 个整数，表示符合题意的方法数。
样例输入:
3 3
样例输出:
2
*/

#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <algorithm>
#include <cmath>

using namespace std;

// 递推状态: f[j][i] 传了j轮球，球在第i个人手里的方案总数
// 容斥原理推导: j - 1轮的时候，球要么在第 i + 1 个人手里，要么在第 i - 1 个人手里
// 递推公式: f[j][i] = f[j - 1][i + 1] + f[j - 1][i - 1]

#define MAX_N 30
#define MAX_M 30

int f[MAX_M + 5][MAX_N + 5] = {0};

int main() {
    int n, m;
    cin >> n >> m;
    f[0][1] = 1;
    for (int j = 1; j <= m; ++j) {
        for (int i = 2; i <= n - 1; ++i) {
            f[j][i] = f[j - 1][i + 1] + f[j - 1][i - 1];
        }
        f[j][1] = f[j - 1][2] + f[j - 1][n];
        f[j][n] = f[j - 1][1] + f[j - 1][n - 1];
    }
    cout << f[m][1] << endl;
    return 0;
}