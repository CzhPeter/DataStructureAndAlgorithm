/*
卡门――农夫约翰极其珍视的一条 Holsteins 奶牛――已经落了到 “垃圾井” 中。
“垃圾井” 是农夫们扔垃圾的地方，它的深度为 D（2≤D≤100）英尺。
卡门想把垃圾堆起来，等到堆得与井深同样高或比井深更高（即，垃圾高度总和 ≥D）时，她就能逃出井外了。
另外，卡门可以通过吃一些垃圾来维持自己的生命。
每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。
假设卡门预先知道了每个垃圾扔下的时间 t（1≤t≤1000），以及每个垃圾堆放的高度 h（1≤h≤25）
和吃进该垃圾能增加维持生命的时间 f（1≤f≤30），要求出卡门最早能逃出井外的时间，
假设卡门当前体内有足够持续 10 小时的能量，如果卡门 10 小时内（不含 10 小时，维持生命的时间同）没有进食，
卡门就将饿死。特别地，若体力值为 0 时吃下垃圾或逃出井外也不会饿死。
输入格式:
第一行为两个整数，D 和 G（1≤G≤100），G 为被投入井的垃圾的数量。
第二到第 G+1 行每行包括三个整数：T（1≤T≤1000），表示垃圾被投进井中的时间；
F（1≤F≤30），表示该垃圾能维持卡门生命的时间；
和 H（1≤H≤25），该垃圾能垫高的高度。
输出格式:
如果卡门可以爬出陷阱，输出一个整数，表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。
样例输入:
20 4
5 4 9
9 3 2
12 6 10
13 1 1
样例输出:
13
*/

#include <iostream>
#include <vector>
#include <string>
#include <deque>
#include <algorithm>
#include <cmath>
#include <cstring>

using namespace std;

// dp状态: dp[i][j] 前 i 个垃圾
// j 的含义可能性: 1. 高度；2. 生存时间
// 以 1 为例: dp[i][j] 前 i 个垃圾，牛站在 j 高度的情况下，所能生存的最长时间
// 状态转移: 
// 1. 吃掉第 i 个垃圾: dp[i - 1][j] + f[i]，f[i] 代表第 i 个垃圾能提供的生存时长，
// 同时需要满足 dp[i - 1][j] >= t[i]，即奶牛要能活到第 i 个垃圾掉下来
// 2. 填第 i 个垃圾: dp[i - 1][j - h[i]]，同时需要满足 dp[i - 1][j - h[i]] >= t[i]，意义同上

#define MAX_N 100

struct Data {
    int t, f, h; // 时间，生命，高度
} arr[MAX_N + 5];

bool cmp(const Data &a, const Data &b) {
    return a.t < b.t;
}

int dp[2 * MAX_N + 5];

int main() {
    int D, G; // D 井深度，G 垃圾数量
    cin >> D >> G;
    for (int i = 0; i < G; ++i) {
        cin >> arr[i].t >> arr[i].f >> arr[i].h;
    }
    sort(arr, arr + G, cmp);
    dp[0] = 10; // 初始生命值
    for (int i = 0; i < G; ++i) {
        for (int j = D; j >= 0; --j) {
            // 前 i - 1 件物品在高度 j 时的生命值，无法撑到第 i 件物品掉下来
            if (dp[j] < arr[i].t) continue;
            // 前 i - 1 件物品在高度 j，加上第 i 件物品堆积的高度，可以跳出井
            if (j + arr[i].h >= D) {
                cout << arr[i].t << endl; // 此时第 i 件物品的掉落时间就是最短时间
                return 0;
            }
            // 堆积第 i 件物品，高度为 j + arr[i].h，更新最大生命值
            dp[j + arr[i].h] = max(dp[j], dp[j + arr[i].h]);
            // 吃掉第 i 件物品，高度为 j
            dp[j] += arr[i].f;
        }
    }
    cout << dp[0] << endl; // 无法跳出井，还是站在 0 位置，吃掉所有垃圾
    return 0;
}